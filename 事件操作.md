## 13. 事件操作

``` javascript
//[4324]
/* 事件的工具方法 */
jQuery.event = {
	global
	add            //add remove trigger 重点
	remove
	trigger
	dispatch       //后面是前面三个的辅助
	handlers
	props
	fixHooks
	keyHooks
	mouseHooks
	fix
	special
	simulate
}

/* 事件的工具构造函数 */
jQuery.Event = function( src, props ) {
}

jQuery.Event.prototype = {
	isDefaultPrevented
	isPropagationStopped
	isImmediatePropagationStopped
	preventDefault
	stopPropagation
	stopImmediatePropagation
}


/* jQuery实例对象的扩展 */
jQuery.fn.extend({
	on
	one
	off
	trigger
	triggerHandler
})

/* [6720] jQuery实例对象的扩展, 调用$().on $().trigger */
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

/* jQuery实例对象的扩展 */
jQuery.fn.extend({
	hover
	bind
	unbind
	delegate
	undelegate
}
```

>内容解析

(一) `$().on()`/`$().trigger()`/`$().off()`

``` javascript

//非自定义事件
var $input = $('#input');

$input.on('click',function() {
   alert(1);
});

$input.trigger('focus');    //触发了默认的focus效果
$input.trigger('click');    //触发了click事件,alert(1)

//自定义事件
$input.on('show',function() {
    alert(2);
});

$input.on('show',function() {
	alert(3);
    $input.off('show');     //取消监听
});

$input.trigger('show');     //alert(1)/alert(2)
$input.trigger('show');     //不会触发
```
(二)  事件流

- **事件冒泡**: 事件开始时是最具体的元素接收，然后逐级向上传播到较为不具体的节点
- **事件捕获**: 首先document对象接收事件，然后事件沿DOM树向下，一直传播到事件的实际目标

>提示: 由于老的浏览器不支持事件捕获，建议使用事件冒泡

(三) `DOM0/DOM2`事件

``` javascript
/*DOM0级事件处理程序*/

//每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick
//使用DOM0级方法指定的事件处理程序被认为是元素的方法，所以事件处理程序是在元素作用域中运行的，this指代button对象

var btn = document.getElementById("myButton");
btn.onclick = function(){
    alert(this.id); //myButton
}

//这些代码运行以前不会指定时间出里程序，因此如果这些代码在页面中位于按钮后面，可能会在一段时间内单击没有反应
btn.onclick = null; //删除事件处理程序

/*DOM2级事件处理程序*/

btn.addEventListener("click",function(){
    alert(this.id);
},false);   //最后一个参数 false：冒泡阶段被触发   true：事件捕获

//与DOM0级一样，添加的事件处理程序也是在其依附的元素作用域中运行
//添加多个事件处理程序
btn.addEventListener("click",function(){
    alert("hello world!");  //与上面事件执行顺序不同而已，是按键的两个事件
},false);

//addEventListener添加的事件只能用removeEventListener来移除
btn.removeEventListener("click",function(){
    alert("hello world!");  //并没有移除这个事件，原因是第二个参数这个函数与上面添加的函数并不是同一个，所以参数不一致了
},false);                   //而移除则需要add和remove函数的三个参数一致

var clickHandler = function(){
    alert("The third click thing");
};

btn.addEventListener("click",clickHandler,false);   //添加第三个方法
btn.removeEventListener("click",clickHandler,false); //clickHandler是同一个参数了，可以移除事件了

//addEventListener添加的匿名函数对应的事件将不能被移除，因为参数不会一致了
//大多数情况都是将事件处理程序添加到事件流的冒泡阶段

//IE事件处理程序
//IE9之前的IE不支持addEventListener和removeEventListener
//IE5及以后的版本定义了类似的方法attachEvent和detachEvent
//attachEvent detachEvent 与addEventListener removeEventListener类似
//只是第一个参数是"onclick"而不是"click"
//也可以添加多事件
//只有两个参数，因为默认是冒泡阶段触发事件

/* 跨浏览器的事件处理程序 */

//用到了能力检测
//使用DOM0 或者DOM2和IE方法来添加事件
var EventUtil = {
    addHandler: function(element,type,handler){
        if(element.addEventListener){
            element.addEventListener(type,handler,false); //只需要关注冒泡阶段
        } else if(element.attachEvent){
            element.attachEvent("on" + type,handler);
        } else{
            element["on" + type] = handler; //DOM0级事件处理
        }
    },
    removeHandler:function(element,type,handler){
        if(element.removeEventListener){
            element.removeEventListener(type,handler,false);
        } else if(element.detachEvent){
            element.detachEvent("on" + type,handler);
        } else{
            element["on" + type] = null;
        }
    }
}

var handler = function(){
    alert("EventUtil is using!");
}

EventUtil.addHandler(btn,"click",handler);
EventUtil.removeHandler(btn,"click",handler);

//需要注意的是IE的detachEvent和addEvent的作用域是window而不是触发的事件的元素
//并且DOM0级对每个事件只支持一个事件处理程序
var div = document.getElementById('div');
div.onclick = function() {
    console.log('click div1');
};

div.onclick = function() {
    console.log('click div2');  //只打印这个,覆盖了上面的onclick属性
};

```

(四) `event`事件对象

``` javascript
/*DOM中的事件对象event*/

var btn = document.getElementById("myButton");

//event.type / event.target / event.currentTarget
//target  		 事件的目标
//currentTarget  事件处理程序当前正在处理事件的那个元素
//type           事件类型
btn.addEventListener("click",function(event){
    alert(event.type); //click
    alert(event.currentTarget === this); //true
    alert(event.target === this);        //true this和当前正在处理事件的那个元素（currentTarget）和事件的目标（target）一样。
},false);

document.body.onclick = function(event){
    alert(event.currentTarget === document.body);                       //true
    alert(this === document.body);                                      //true
    alert(event.target === document.getElementById("myButton"));        //点击按钮 true 点击非按钮的body区域 false
}

//点击按钮时，事件处理程序是注册到body元素上的，然而，target元素却等于按钮元素，因为它是click事件真正的目标。
//由于按钮上并没有注册事件处理程序，结果click事件就冒泡到了document.body，在那里事件才得到了处理

//event.preventDefault() / event.cancelable
//event.preventDefault()  取消事件的默认行为
//event.cancelable        只有cancelable属性为true时，才能preventDefault起作用
var link = document.getElementById("myLink");
link.onclick = function(event){
    alert(event.cancelable);    //true
    event.preventDefault();     //取消默认行为，已经不能连接了
}

//event.stopPropagation  取消事件的进一步冒泡或者捕获

btn.onclick = function(event){
    alert("clicked");
    event.stopPropagation();    //取消事件的进一步冒泡或者捕获
};


document.body.onclick = function(event){
  alert("Body clicked");        //如果没有上面的stopPropagation这个就触发了,所以这里click事件不会传播到document.body
};

//event.eventPhase
//1. 表示捕获阶段
//2. 表示"处于目标"阶段
//3. 表示冒泡

//捕获时不太具体的节点更早的接收事件 document -> html -> body -> ...
//默认冒泡的时候，顺序则相反，先处于目标的事件先触发，然后往上传递

//DOM2级事件 规定了事件流的三个阶段：事件捕获阶段 处于目标阶段和事件冒泡阶段
//首先发生的事件捕获 然后是实际的目标接收到事件 最后是冒泡阶段
//此时如果点击button按钮

btn.onclick = function(event){
  alert("处于目标"+ event.eventPhase); //2
	//此时，this,target和currentTarget始终相等
};

document.body.addEventListener("click",function(event){
    alert("处于捕获阶段" + event.eventPhase); //1
},true); //参数为true 设置为捕获模式

document.body.onclick = function(event){
    alert("处于冒泡阶段" + event.eventPhase); //3
}

//事件处理程序执行期间，event对象才会存在，一旦事件处理程序执行完成，event对象就会被销毁


/*IE中的事件对象event*/
//在IE8及以前的版本中，通过设置属性注册事件处理程序(例如上面的window.onload)
//调用它们时并未传递事件对象 需要通过全局对象window.event来获取事件对象

//event.type / event.srcElement(类似于event.target)
btn.onclick = function(){
    var event = window.event;
    alert(event.type); //click chorme和IE都可以
    alert(event.srcElement === this); //true
};

btn.attachEvent("onclick",function(event) {
    alert(event.srcElement === this); //false
});

//event.returnValue(event.preventDefault) / event.cancelBubble (event.stopPropagation)

//IE不支持事件捕获，但是支持取消冒泡
```

跨浏览器兼容写法

``` javascript
var EventUtil = {
    addHandler: function(element,type,handler){
        if(element.addEventListener){
            element.addEventListener(type,handler,false); //只需要关注冒泡阶段
        } else if(element.attachEvent){
            element.attachEvent("on" + type,handler);
        } else{
            element["on" + type] = handler; //DOM0级事件处理
        }
    },
    removeHandler:function(element,type,handler){
        if(element.removeEventListener){
            element.removeEventListener(type,handler,false);
        } else if(element.detachEvent){
            element.detachEvent("on" + type,handler);
        } else{
            element["on" + type] = null;
        }
    },

    getEvent:function(event){
        return event ? event : window.event;
    },

    getTarget:function(event){
        return event.target || event.srcElement;
    },

    preventDefault:function(event){
        if(event.preventDefault){
            event.preventDefault();
        } else{
	        //IE9之前的IE中，可以通过设置事件对象的returnValue属性为false
            event.returnValue = false;
        } else{

	 		return false;
		}
    },

    stopPropagation:function(event){
        if(event.stopPropagation){
            event.stopPropagation();
        } else{
            event.cancelBubble = true;
        }
    }
};


var btn = document.getElementById("myButton");
btn.onclick = function(event){
    event = EventUtil.getEvent(event);
    //alert(event);
    //var target = EventUtil.getTarget(event);
    //alert(target);
    EventUtil.stopPropagation(event);
    //event.preventDefault();
};

```

(五) 内存和性能

**事件委托**: 若果可行的话，可以考虑为`document`对象添加一个事件处理程序，用以处理页面上发生的某种特定类型的事件
-  1.`document`对象很快就能访问到，可以在页面生命周期的任何时间点上为它添加事件处理程序， 无需等待`DOMContentLoaded`和`load`事件，只要可单击的元素呈现在页面上，就可以立即具备适当的功能
- 2.在页面中设置事件处理程序所需的时间更少，所需的`DOM`引用更少，所花的时间更少
- 3.整个页面占用的内存空间更少，能够提升整体性能

>提示: 适合使用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup和keypress。

**移除事件**: 不需要的时候移除事件处理程序，可以解决内存与性能问题。

``` javascript
//1.从文档中移除带有事件处理程序的元素时，这可能是通过纯粹的DOM操作，例如removeChild()和replaceChild()方法
//  但是更多的是发生在使用innerHTML替换页面中某一部分的时候，如果带有事件处理程序的元素被innerHTML删除了，
//  那么原来添加到元素中的事件处理程序极有可能无法被当做垃圾回收

/*var myBtn = document.getElementById("myBtn");
myBtn.onclick = function(){
    document.getElementById("myDiv").innerHTML = "Processing..."; //麻烦了，带有事件处理程序的button按钮被innerHTML删除了
};*/

//当按钮从页面移除以后，它还带着一个事件处理程序
//事件处理程序仍然与按钮保持着引用关系
//如果知道元素即将移除，那么最好手工移除事件处理程序

//事件委托由于把是事件处理程序制定给较高层次的元素，所以即使使用innerHTML把子元素替换掉了，
//由于事件不直接引用该元素，而是引用较高层次的元素，可以避免这个问题

//卸载页面之前最好（可能是两个页面之间来回切换或者刷新页面）先通过onunload事件处理程序移除所有的时间处理程序
//而事件委托技术表现出它的优势，跟踪的时间处理程序越少，移除它们就更容易

```

(六) 事件处理程序的返回值

``` javascript
//通过设置对象属性或HTML属性注册事件处理程序的返回值非常有意义
//返回值false就是告诉浏览器不要执行这个事件相关的默认操作
//例如表单提交按钮的onclick事件处理程序能返回false阻止浏览器提交表单

function submit(){
    return false;
}

window.onbeforeunload = function(){
    return '是否跳转到新页面？';
};

//onbeforeunload事件处理程序的返回值也非常有意义 当浏览器要跳转到新页面时触发这个事件
//如果事件处理程序中返回一个字符串，那么它将出现在询问用户是否想离开当前页面的标准对话框

//事件处理程序的返回值中对通过属性注册的处理程序有意义
//使用addEventListener()或者attachEvent()注册事件处理程序转而必须调用preventDefault()方法或设置事件对象的
//returnValue属性
```
(七) 事件处理程序的优先级

- 通过设置对象属性(DOM0)或HTML属性注册的处理程序一直优先调用
- 使用`addEventListener()`注册的处理程序按照它们的注册顺序调用
- 使用`attachEvent()`注册的处理程序可能按照任何顺序调用 所以代码不应该依赖调用顺序

(八) 事件传播

``` javascript
//当事件目标是window对象或其他一些单独的对象时（比如XMLHttpRequest）
//浏览器简单的通过调用对象上适当的处理程序响应事件
//当事件目标是文档或文档元素时，情况比较复杂

//在调用在目标元素上注册事件处理函数后，大部分事件会‘冒泡’到DOM树根
//调用目标父元素的事件处理程序，然后调用在目标的祖父元素上注册事件处理程序
//这会一直到Document对象 最后到达Window对象

//事件冒泡在大量单独文档元素上注册处理程序提供了替代方案
//即在共同的祖先元素上注册一个处理程序来处理所有的事件

//例如可以在form元素上注册change事件处理程序来取代
//在表单的每个元素上注册change事件处理程序


//尽管发生在文档元素上的大部分事件都会冒泡，值得注意的是focus blur和scroll事件不会冒泡
//文档元素上的load事件会冒泡，但它会在document对象上停止冒泡而不会传播到Window对象
//只有当整个文档都加载完毕时才会触发Window的load事件

//事件传播的三个阶段
/**
 * 1.第三阶段 事件冒泡
 * （所谓事件冒泡即在调用目标元素的父元素的事件处理程序
 *   然后调用在目标的祖父元素上注册的事件处理程序，会一直到Document对象，最后到Window对象）
 * 2.第二阶段 目标对象本身的事件处理程序调用时
 * 3.第一阶段 发生在目标处理程序调用之前，成为‘捕获’阶段
 *   例如addEventListener()把第一个布尔值作为其第三个参数 如果是true，
 *   那么事件处理程序被注册为捕获事件处理程序，会在事件传播的第一个阶段调用
 *
 *   事件传播的捕获阶段像是反向的事件冒泡
 *   最先调用Window对象的捕获处理程序 然后是Document对象的捕获处理程序 接着是body对象的
 *   再然后是DOM树向下直到调用事件目标的父元素的捕获事件处理程序
 *   在目标对象本身上注册的捕获事件处理程序不会被调用
 *
 *   事件捕获提供了在事件没有送达目标之前查看它们的机会
 *   事件捕获能用于程序调试，或用于后面介绍的事件取消技术
 *   过滤掉事件从而使目标事件处理程序绝不会被调用
 *   事件捕获捕获常用语处理鼠标拖放 因为要处理的拖放的位置不能是这个元素内部的子元素
 *
 */
```




## 13.1 JQuery实例对象扩展`jQuery.fn.extend`

这里的`jQuery.fn.extend`主要调用`jQuery.event`对象的方法


``` javascript
jQuery.fn.extend({
	on
	one
	off
	trigger
	triggerHandler
})

jQuery.fn.extend({
	hover
	bind
	unbind
	delegate
	undelegate
}
```

## 13.1.1 `$().on()`

- 调用`$.event.add()`
- 该函数主要是对传入参数做处理,并不做绑定事件操作
- 调用路线:  `$().on()`(参数处理) -> `$().event.add()`(数据缓存) -> `$().event.dispatch()`(事件操作处理) -> `$().event.fix()` (事件兼容性处理) -> `$().event.special()`(特殊事件处理) -> `$().event.handlers()`(事件执行顺序的队列操作)

>源码
``` javascript
jQuery.fn.extend({
	//[5028]
	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		// $().on({'click': function(){}, 'mouseover': function(){}} )
		// 详见(二)
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			// 仍然拆分成this.on执行
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		// 详见(一) 对不同参数进行处理, 两个参数情况
		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		// 三个参数情况
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		// 针对$.fn.extend中的one方法,只执行一次 $().one('click',function(){})
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				// 取消事件操作
				jQuery().off( event );  //jQuery() = jQuery(this)
				// 执行事件handler
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			// guid 绑定事件的唯一标识
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		// 针对$(),可能是多个元素,进行循环操作
		return this.each( function() {
			// on最终调用$.event.add方法
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
})
```
>内容解析

(一) 使用案例

``` javascript
//html
<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
</ul>

//1. 2个参数情况
$('ul').on('click',function() {
   alert(1);
});

//2. 3个参数情况(data可以传递参数到内部)
$('ul').on('click',{name: 'ziyi2'},function(e) {
    alert(e.data.name); //ziyi2
});

//3. 3个参数情况(事件委托,其实是ul监听click事件)
$('ul').on('click','li',function() {
    $(this).css('background','red');
})

//4. 4个参数情况(事件委托+data传递参数)
$('ul').on('click','li',{name:'ziyi2'},function(e){
   $(this).html(e.data.name)
});
```


(二) 传入的参数是`obj`

``` javascript
$('ul').on({
	'click': function(){
	},
	'mouseover': function(){
	}
})
```


## 13.1.2 `$().one()`

>源码
``` javascript
one: function( types, selector, data, fn ) {
	//最后一个参数1很重要
	//调用$().off()
	//调用事件处理函数
	return this.on( types, selector, data, fn, 1 );
},
```

## 13.1.3 `$().off()`
- 调用`$.event.remove()`

```javascript
off: function( types, selector, fn ) {
	var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		//遍历DOM集合
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},
```

## 13.1.4 `$().trigger()`

- 调用`$.event.trigger()`

>源码

``` javascript
trigger: function( type, data ) {
	//遍历选中的DOM集合,调用$.event.trigger()
	return this.each(function() {
		jQuery.event.trigger( type, data, this );
	});
},
```

>内容解析

``` javascript

<input type="text" id="input">

$('#input').focus(function() {
   $(this).css('background','red');
});
$('#input').trigger('focus');				//主动触发focus事件,光标自动定位到input
```

## 13.1.5 `$().triggerHandler()`

>源码

``` javascript
triggerHandler: function( type, data ) {
	var elem = this[0];
	if ( elem ) {
		//参数true就是用于阻止触发事件的默认行为
		return jQuery.event.trigger( type, data, elem, true );
	}
}
```

>内容解析

``` javascript
$('#input').focus(function() {
   $(this).css('background','red');
});
$('#input').triggerHandler('focus');		//主动触发focus事件,光标不会定位(不会触发当前事件的默认行为)

```

## 13.2 事件工具对象`jQuery.Event`

``` javascript
//[4324]
jQuery.event = {
    global        //事件的全局属性(源码没用到)
    add           //绑定事件,主要是对事件的data缓存进行操作
    remove        //取消绑定事件
    trigger       //主动触发事件
    dispatch      //分发事件的具体操作
    handlers      //函数执行顺序的操作
    props         //JQuery中的event属性共享原生JS的event属性
    fixHooks      //收集event兼容的集合
    keyHooks      //键盘的event兼容
    mouseHooks    //鼠标的event兼容
    fix           //event对象的兼容处理
    special       //特殊事件的处理
    simulate
}

//构造函数
jQuery.Event = function( src, props ) {
}

jQuery.Event.prototype = {
    isDefaultPrevented
    isPropagationStopped
    isImmediatePropagationStopped
    preventDefault
    stopPropagation
    stopImmediatePropagation
}
```

## 13.2.1 `$.event.add()`

- 被`$().on()`调用
- 最终调用`$.event.dispatch()` (具体的事件操作)
- 该函数主要是对事件`data`进行缓存处理

>源码


``` javascript
jQuery.event = {
	add: function( elem, types, handler, data, selector ) {
		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		// 一般情况下都有elemData,除非是text/comment等节点
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		// 如果之前没有标识符,则加上事件唯一标识符
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		// 如果elemData.events不存在,则第一次初始化这个结构
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		//如果elemData.handle不存在,则第一次初始化这个handle
		if ( !(eventHandle = elemData.handle) ) {
			//eventHandle是事件监听的执行函数
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				// 如果触发过jQuery.event.trigger()则不会再触发了
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
					//执行分发事件,注意这里的arguments = [e] e是原生的event事件对象,将原生的event事件对象传入了dispatch函数
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}
		// types可能是多个事件类型,详见(四),将它们转换成数组
		// Handle multiple events separated by a space
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			// 如果有兼容性则需要添加兼容性处理的函数
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					//添加事件处理函数,这是核心
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				//elemData数据缓存
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		// 防止内存泄漏
		elem = null;

		console.log(elemData);
	},
}
```


>内容解析


(一) 模拟实现(说明需要数据缓存)

``` javascript
function Event() {}

Event.prototype.on = function(elem,type,handler) {
    elem.listeners = elem.listeners || {};
    elem.listeners[type] = elem.listeners[type] || [];
    elem.listeners[type].push(handler);
    elem.addEventListener(type,handler,false);   //false是冒泡机制
};

Event.prototype.off = function(elem,type,handler) {
    elem.removeEventListener(type,handler,false);
    delete elem.listeners[type];
};

Event.prototype.trigger = function(elem,type) {
    var listeners = elem.listeners[type] || [];
    for(var i=0,len=listeners.length; i<len; i++) {
        listeners[i]()
    }
};

var input = document.getElementById('input');

function fn1() {
    alert(1);
}

function fn2() {
    alert(2);
}

//非自定义事件
var event = new Event();
event.on(input,'click',fn1);   //添加
event.off(input,'click',fn1);  //取消添加
event.on(input,'click',fn1);   //只触发fn1一次

//自定义事件
event.on(input,'show',fn2);
event.trigger(input,'show');
```

(二) 数据缓存结构

```

$(function(){
    $('#div1').on('click',function(a) {
        console.log('click div');
    });

    $('#div1').on('click','span',function(b) {
        console.log('click span');
    });

    $('#div1').on('mouseover.ziyi2',function(c) {
        console.log('mouserover');
    });
});

/*

[4328]
$.event.add 底部 console.log(elemData);


var elemData = {
    events: {
        'click': [                          //arr.length = 2 arr.delegateCount = 1 (委托计数值)
            {
                data: undefined,
                guid: 2,                    //当前事件的唯一标识
                handler: function(b) {},    //事件函数
                namespace: "",              //命名空间
                needsContext: false,        //委托人是否是伪类(span:last)
                origType: "click",          //mouseenter(浏览器不支持会用mouseover模拟)
                selector: "span",           //委托(委托会首先放到数组的前面)
                type: "click"               //事件类型(模拟事件类型)
            },
            {
                data: undefined,
                guid: 1,
                handler: function(a) {},
                needsContext: undefined,
                origType: "click",
                selector: undefined,        //没有委托
                type: "click"
            }
        ],

        'mouserover': [                     //arr.length = 1 arr.delegateCount = 0 (委托计数值)
            {
                data: undefined,
                guid: 3,                    //当前事件的唯一标识
                handler: function(c) {},
                namespace: "ziyi2",         //命名空间
                needsContext: undefined,
                origType: "mouseover",
                selector: undefined,        //没有委托
                type: "mouseover"
            }
        ]
    },

    handle: function(e) {                   //真正的事件函数

    }
};
*/
```

(三) 命名空间


``` javascript
$('#div2').on('click.click1',function() {
	alert(1);
});

$('#div2').on('click.click2',function() {
    alert(2);
});

$('#div2').on('click',function() {
    alert(3);
});

//也可以多层命名空间
$('#div1').on('mouseover.ziyi2.add',function(c) {
    console.log('mouserover');
});

$('#div2').trigger('click.click1'); //1
```


(四) 多事件

``` javascript
$('#div1').on('click mouseover focus',function(a) {
	console.log('click div');
});
```


## 13.2.2 `$.event.dispatch()`

>源码

``` javascript
dispatch: function( event ) {

	// Make a writable jQuery.Event from the native event object
	// 从$.event.add中接收了原生的event对象,将其传入$.event.fix函数处理成$的event对象
	// 这里返回的event是做过兼容性处理的event对象
	event = jQuery.event.fix( event );

	var i, j, ret, matched, handleObj,
		handlerQueue = [],
		args = core_slice.call( arguments ),
		handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
		special = jQuery.event.special[ event.type ] || {};

	// Use the fix-ed jQuery.Event rather than the (read-only) native event
	args[0] = event;
	event.delegateTarget = this;

	// Call the preDispatch hook for the mapped type, and let it bail if desired
	if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
		return;
	}

	// Determine handlers
	handlerQueue = jQuery.event.handlers.call( this, event, handlers );

	// Run delegates first; they may want to stop propagation beneath us
	i = 0;
	while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
		event.currentTarget = matched.elem;

		j = 0;
		while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

			// Triggered event must either 1) have no namespace, or
			// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
			if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

				event.handleObj = handleObj;
				event.data = handleObj.data;
				//这里是真正的执行,注意args就是处理后的event事件对象
				//如果有兼容性则走第一个,否则走传入的$().on(type,handler)的handler
				ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
						.apply( matched.elem, args );

				//如果事件执行函数return false,则阻止默认行为和冒泡,详见(一)
				if ( ret !== undefined ) {
					if ( (event.result = ret) === false ) {
						event.preventDefault();
						event.stopPropagation();
					}
				}
			}
		}
	}

	// Call the postDispatch hook for the mapped type
	if ( special.postDispatch ) {
		special.postDispatch.call( this, event );
	}

	return event.result;
},
```


>内容解析

(一)  阻止冒泡和阻止默认行为

```
$(function(){
  $('#div1').on('click','span',function(e) {
     console.log('click span');
       //e.preventDefault();   //return false就是这两句功能
       //e.stopPropagation();
       return false;           //阻止冒泡和阻止默认事件
   });

   $('#div1').on('click',function(e) {
       console.log('click');
   });
});

//点击span元素,由于阻止冒泡,因此div1的click事件是不是触发的,不会打印click
```



## 13.2.3 `$.event.handlers()`

- 作用是实现事件队列

``` javascript
handlers: function( event, handlers ) {
	var i, matches, sel, handleObj,
		handlerQueue = [],
		delegateCount = handlers.delegateCount,
		cur = event.target;

	// Find delegate handlers
	// Black-hole SVG <use> instance trees (#13180)
	// Avoid non-left-click bubbling in Firefox (#3861)
	if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

		for ( ; cur !== this; cur = cur.parentNode || this ) {

			// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
			if ( cur.disabled !== true || event.type !== "click" ) {
				matches = [];
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];

					// Don't conflict with Object.prototype properties (#13203)
					sel = handleObj.selector + " ";

					if ( matches[ sel ] === undefined ) {
						matches[ sel ] = handleObj.needsContext ?
							jQuery( sel, this ).index( cur ) >= 0 :
							jQuery.find( sel, this, null, [ cur ] ).length;
					}
					if ( matches[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, handlers: matches });
				}
			}
		}
	}

	// Add the remaining (directly-bound) handlers
	// 没有事件委托的情况下走这里
	if ( delegateCount < handlers.length ) {
		//放入需要执行的事件队列
		handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
	}

	return handlerQueue;
},
```

>内容解析

(一) 事件触发顺序


``` javascript
<div id="div1">this is <span> this is span </span>div</div>


 $(function(){
   $('#div1').on('click',function() {
       console.log('click1');
   });

   $('#div1').on('click',function() {
       console.log('click2');
   });

   $('#div1').on('click','span', function() {
       console.log('click span');
   });
});

//点击span元素, 打印顺序 1. click span 2. click1 3. click2
//需要注意的是尽管$.event.add中已经在data缓存中把委托的放在最前面,但是如果同时委托多个.委托顺序则不会按照顺序执行.所以需要$.event.handlers函数进行执行顺序的处理
```


## 13.2.4 `$.event.fix()`

- `mouseHooks`
- `keyHooks`

>源码

``` javascript
// Includes some event props shared by KeyEvent and MouseEvent
// jquery的event属性共享原生js的event属性
props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

fixHooks: {},

keyHooks: {
	props: "char charCode key keyCode".split(" "),
	filter: function( event, original ) {

		// Add which for key events
		// which兼容性最差(低版本浏览器不支持)
		// charCode其次
		// keyCode最好
		// 一步步降级做兼容性处理
		if ( event.which == null ) {
			event.which = original.charCode != null ? original.charCode : original.keyCode;
		}

		return event;
	}
},

mouseHooks:
	props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
	//解决鼠标的兼容性的具体操作
	//event: JQuery当中的event对象
	//original: 原生的event对象
	filter: function( event, original ) {
		var eventDoc, doc, body,
			button = original.button; //原生有button属性

		// Calculate pageX/Y if missing and clientX/Y available
		// pageX/pageY有兼容性 -> 距离页面顶端的距离
		// clientX/clientY没有兼容性问题 -> 距离当前屏幕顶端(可视图区)的距离(屏幕会显示页面滚动之后的页面的某一部分)
		// 如果浏览器没有pageX属性
		if ( event.pageX == null && original.clientX != null ) {
			eventDoc = event.target.ownerDocument || document;
			doc = eventDoc.documentElement;
			body = eventDoc.body;

			//pageX = clientX + 滚动距离
			event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
			event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		// Note: button is not normalized, so don't use it
		// which可以代表键盘的键值,也可以代表鼠标点击的左中右键
		// 低版本支持button属性(识别鼠标的点击值)
		// 详见(一)
		if ( !event.which && button !== undefined ) {
			event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
		}

		return event;
	}
},

fix: function( event ) {
    //看有没有缓存,有缓存就不需要执行后面的了
	if ( event[ jQuery.expando ] ) {
		return event;
	}

	// Create a writable copy of the event object and normalize some properties
	var i, prop, copy,
		type = event.type,
		//原生的event属性
		originalEvent = event,
		fixHook = this.fixHooks[ type ];

	//如果fixHook不存在,则继续判断是否要做兼容性处理
	if ( !fixHook ) {
		this.fixHooks[ type ] = fixHook =
			//针对鼠标的兼容性处理
			rmouseEvent.test( type ) ? this.mouseHooks :
			//针对键盘的兼容性处理
			rkeyEvent.test( type ) ? this.keyHooks :
			{};
	}

    //如果有需要做兼容性处理的prop属性,则放入copy,之后会加入jquery的event属性
    //this.props在$.event.fix的上面
	copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

	//面向对象的编程方法
	//创建jQuery下的event对象,增强原生的event对象
	event = new jQuery.Event( originalEvent );

	//将原生event的prop属性赋值给jquery的event属性
	i = copy.length;
	while ( i-- ) {
		prop = copy[ i ];
		event[ prop ] = originalEvent[ prop ];
	}

	// Support: Cordova 2.5 (WebKit) (#13255)
	// All events should have a target; Cordova deviceready doesn't
	// 移动端的事件deviceready没有target,做兼容性处理
	if ( !event.target ) {
		event.target = document;
	}

	// Support: Safari 6.0+, Chrome < 28
	// Target should not be a text node (#504, #13143)
	// 事件源不能是文本,如果是文本就变成他的父级
	if ( event.target.nodeType === 3 ) {
		event.target = event.target.parentNode;
	}

	return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
},






//[4912]
jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	// 容错处理
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	// 如果有额外属性也可以加强
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	// 时间戳,1970年开始的毫秒数
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	// 设置缓存,说明$.event.fix下面的代码执行过了,第二次就不用执行了
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,   //returnFlase是返回false的单纯函数
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	//阻止默认事件
	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	//阻止冒泡
	stopPropagation: function() {
		var e = this.originalEvent;

		//可以使用e.isPropagationStopped()方法来判断是否阻止冒泡
		this.isPropagationStopped = returnTrue;

		//使用原生的方法阻止冒泡行为
		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	//阻止冒泡(也会阻止自身)
	//详见(三)
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};



```

>内容解析

(一) `event.whitch`属性识别鼠标键

``` javascript
$(function(){
    $(document).on('click',function(e) {
        console.log(e.which);       //左:1 中:得不到 右:得不到
    });

	$(document).on('mousedown',function(e) {
         console.log('mousedown:' + e.which);  //左:1 中:2 右:3
    })
});
```


(二) `event`属性

``` javascript
$(function(){
  $('#div1').on('click',function(e) {
      console.log(e);                 //jQuery的event对象(加强了原生的event对象)
      console.log(e.originalEvent);   //原生event对象
  })
});
```


(三) `event.stopImmediatePropagation`

``` javascript

<div id="div1">this is <span> this is span </span>div</div>

//情况一
$(function(){
    //点击span元素,因为会冒泡,所以两者都会触发
    $('#div1').on('click',function(e) {
        console.log('div:click');
    });

    $('span').on('click',function(e) {
        console.log('span:click');
    });
});

//情况二
$(function(){
    //点击span元素,因为阻止冒泡,所以不会触发div的click事件
    $('#div1').on('click',function(e) {
        console.log('div:click');
    });

    $('span').on('click',function(e) {
        console.log('span:click');
        e.stopPropagation();    //阻止冒泡
    });

    $('span').on('click',function(e) {
        console.log('span:click');
    });
});

//情况三
$(function(){
    //点击span元素,因为阻止冒泡得到增强,不仅不会触发div的click事件,也不会触发自身绑定的其他事件
    $('#div1').on('click',function(e) {
        console.log('div:click');
    });

    $('span').on('click',function(e) {
        console.log('span:click1');
        e.stopImmediatePropagation();
    });

    $('span').on('click',function(e) {
        console.log('span:click2');
    });
});
```


## 13.2.5 `$.event.special()`

事件
- load
- focus
- blur
- click 
- beforeunload
- mouseenter
- mouseleave
- focusin
- focusout

属性
- noBuble
- trigger
- delegateType
- _default
- postDispatch
- setup
- teardown
- bindType
- handle


``` javascript
//[4831]
special: {
	//原生不支持冒泡
    load: {
        // Prevent triggered image.load events from bubbling to window.load
        // 详见内容解析一
        noBubble: true
    },
    //原生不支持冒泡
    focus: {
        // Fire native event if possible so blur/focus sequence is correct
        trigger: function() {
            if ( this !== safeActiveElement() && this.focus ) {
                this.focus();
                return false;
            }
        },
        //使用支持冒泡的光标事件来模拟focus
        //详见(二)
        delegateType: "focusin"
    },
    blur: {
        trigger: function() {
            if ( this === safeActiveElement() && this.blur ) {
                this.blur();
                return false;
            }
        },
        delegateType: "focusout"
    },
    click: {
        // For checkbox, fire native event so checked state will be right
        // 让复选框选中需要做特殊处理,详见(三)
        trigger: function() {
            if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
                this.click();
                return false;
            }
        },

        // For cross-browser consistency, don't fire native .click() on links
        // 使用trigger时阻止a标签的默认行为,但是可以触发click监听事件,详见(四)
        _default: function( event ) {
            return jQuery.nodeName( event.target, "a" );
        }
    },

    beforeunload: {
        postDispatch: function( event ) {

            // Support: Firefox 20+
            // Firefox doesn't alert if the returnValue field is not set.
            // 火狐浏览器不会弹出提示,所以需要处理, 详见(五)
            // 注释掉这个语句之后火狐是不会弹提示的
            if ( event.result !== undefined ) {
                event.originalEvent.returnValue = event.result;
            }
        }
    }
},   

// [5004] IE下独有的事件 focusin focusout原生支持冒泡操作
// 其他浏览器通过把focusin/out看成自定义事件做兼容
// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				//模拟事件操作
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					//捕获
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}


// [4976]
// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
// 详见内容解析(六)
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			//详见(六)的模拟事件
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});


```

>内容解析


(一) 自动触发也支持冒泡,`jQuery`对冒泡做了特殊处理,因此要`load`原生不支持冒泡的事件要屏蔽冒泡(例如图片和window都有这个事件,则需要防止冒泡)

``` javascript
$("#div1").on('click',function() {
   alert('div click');
});

$("span").on("click",function() {
    alert("span click");
});

$("span").trigger("click"); //span click div click
```

(二) chrome一直弹`alert`

``` javascript
//div默认是没有focus事件的,但是jquery通过模拟支持冒泡的光标事件(focusin/focusout)来实现
$("#div1").delegate('input','focus',function() {
   alert('div focus');
});
```

(三) 触发复选框的选中状态

``` javascript
<input type="checkbox">
$("input").on('click',function() {});
$("input").trigger('click');
```

(四) 阻止`a`标签的默认行为

``` javascript
$("a").on('click',function() {
    alert('a click')
});
$("a").trigger('click'); //a click 但是页面不会跳转
```

(五) 离开页面事件的兼容性

``` javascript
$(window).on('beforeunload',function() {
   return '你要离开页面么?';
});
```

(六) 利用`mouseover/mouseout`模拟`onmouseenter/onmouseleaver`事件

``` javascript
<div id="div1" style="width: 200px;height: 200px;background: red;">
    <div id="div2" style="width: 100px;height: 100px;background: green;"></div>
</div>

var div1 = document.getElementById('div1'),
    div2 = document.getElementById('div2'),
    span1 = document.getElementById('span1');

div1.onmouseover= function(e) {
    span1.innerHTML += 'over' + e.target.id;
};

div1.onmouseout = function(e) {
    span1.innerHTML += 'out' + e.target.id;
};

//1.从body移入红色的div1, span.innerHTML = overdiv1;
//2.从div1移入div2, span.innerHTML = overdiv1outdiv1overdiv2;
//说明: 为什么不是overdiv1outdiv1而是overdiv1outdiv1overdiv2,因为onmouseover支持冒泡,这个是odiv2冒泡到odiv1触发的,所以结果是121
//3.从div2移入div1, span.innerHTML = overdiv1outdiv1overdiv2outdiv2overdiv1
//说明: outdiv2说明div2的onmouseout事件冒泡到了div1,所以触发了div1的onmouseout事件
//4.从div1移入body, span.innerHTML = overdiv1outdiv1overdiv2outdiv2overdiv1outdiv1
```
有的时候这种冒泡的能力并不是我们所期望的,例如我们期望`div1`移入移出时可以实现`div2`显示状态的转变


``` javascript
var div1 = document.getElementById('div1'),
    div2 = document.getElementById('div2'),
    span1 = document.getElementById('span1');

div1.onmouseover= function(e) {
    span1.innerHTML += 'over' + e.target.id;
    div2.style.display = "block";
};

div1.onmouseout = function(e) {
    span1.innerHTML += 'out' + e.target.id;
    div2.style.display = "none";
};

//在body和div1之间不停的移入移出是可以发现div2不停的显示隐藏显示隐藏效果的切换
//但是在div1和div2之间的移入移出发现div2是一直在显示的,起始是因为div1的两个事件同时都触发了,所以我们看不出变化的效果
```

但是`onmouseenter`和`onmouseleaver`是不会冒泡的,子级不会影响父级的操作

``` javascript
div1.onmouseenter= function(e) {
    span1.innerHTML += 'over' + e.target.id;
    div2.style.display = "block";
};

div1.onmouseleave = function(e) {
    span1.innerHTML += 'out' + e.target.id;
    div2.style.display = "none";
};

//在body和div1之间不停的移入移出是可以发现div2不停的显示隐藏显示隐藏效果的切换
//但是在div1和div2之间的移入移出发现div2是一直在显示的,但是两个事件都没有触发,因为只是在div1内部移动,而div2不会影响div1的操作
```

但是`onmouseenter`和`onmouseleaver`有兼容性问题,有特殊的浏览器不支持,而`mouseover/mouseout`所有的浏览器都支持,因此可以利用`mouseover/mouseout`来模拟`onmouseenter`和`onmouseleaver`事件,从而使子级不影响父级的操作

``` javascript
//判断el1元素是否包含el2元素,如果包含返回true
//多数浏览器支持el1.contains(el2)方法,返回true则表示包含
//但是火狐不支持,火狐使用el1.compareDocumentPosition(el2)方法,返回16则说明包含
function elContains(el1, el2) {
    return el1.contains
        ?
        el1 != el2 && el1.contains(el2)
        :
        !!(el1.compareDocumentPosition(el2) & 16);
}


//relatedTarget 事件属性返回与事件的目标节点相关的节点。
//对于 mouseover 事件来说，该属性是鼠标指针移到目标节点上时所离开的那个节点。
//对于 mouseout 事件来说，该属性是离开目标时，鼠标指针进入的节点。
//对于其他类型的事件来说，这个属性没有用。


div1.onmouseover= function(e) {

    var a = this,
        e = e || window.event, //兼容性处理
        b = e.relatedTarget;

    console.log(a);
    console.log(b);

    //如果a不包含b,且a不等于b,即判断是从外部移入当前元素,而不是从当前元素的内部子元素移入当前元素或不是当前元素移入内部子元素则触发
    if(!elContains(a,b) && a!=b) {
        span1.innerHTML += 'over' + e.target.id;
    }
};

div1.onmouseout = function(e) {
    var a = this,
        e = e || window.event, //兼容性处理
        b = e.relatedTarget;

    //如果a不包含b,且a不等于b,即判断是移出当前元素,而不是从当前元素的移入当前元素的子元素或不是当前元素的子元素移入当前元素则触发
    if(!elContains(a,b) && a!=b) {
        span1.innerHTML += 'out' + e.target.id;
    }
};
```


## 13.2.6 `$.event.trigger()`

>源码

``` javascript
trigger: function( event, data, elem, onlyHandlers ) {
	var i, cur, tmp, bubbleType, ontype, handle, special,
		eventPath = [ elem || document ],
		type = core_hasOwn.call( event, "type" ) ? event.type : event,
		namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

	cur = tmp = elem = elem || document;

	// Don't do events on text and comment nodes
	// text和注释节点return
	if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
		return;
	}

	// focus/blur morphs to focusin/out; ensure we're not firing them right now
	if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
		return;
	}

	if ( type.indexOf(".") >= 0 ) {
		// Namespaced trigger; create a regexp to match event type in handle()
		namespaces = type.split(".");
		type = namespaces.shift();
		namespaces.sort();
	}
	ontype = type.indexOf(":") < 0 && "on" + type;

	// Caller can pass in a jQuery.Event object, Object, or just an event type string
	// 处理event,生成jquery的event对象
	event = event[ jQuery.expando ] ?
		event :
		new jQuery.Event( type, typeof event === "object" && event );

	// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
	event.isTrigger = onlyHandlers ? 2 : 3;
	event.namespace = namespaces.join(".");
	event.namespace_re = event.namespace ?
		new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
		null;

	// Clean up the event in case it is being reused
	event.result = undefined;
	if ( !event.target ) {
		event.target = elem;
	}

	// Clone any incoming data and prepend the event, creating the handler arg list
	data = data == null ?
		[ event ] :
		jQuery.makeArray( data, [ event ] );

	// Allow special events to draw outside the lines
	special = jQuery.event.special[ type ] || {};
	if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
		return;
	}

	// Determine event propagation path in advance, per W3C events spec (#9951)
	// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
	// 冒泡事件处理
	if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
		
		bubbleType = special.delegateType || type;
		//一直找寻父节点
		if ( !rfocusMorph.test( bubbleType + type ) ) {
			cur = cur.parentNode;
		}
		for ( ; cur; cur = cur.parentNode ) {
			eventPath.push( cur );
			tmp = cur;
		}

		// Only add window if we got to document (e.g., not plain obj or detached DOM)
		if ( tmp === (elem.ownerDocument || document) ) {
			eventPath.push( tmp.defaultView || tmp.parentWindow || window );
		}
	}

	// Fire handlers on the event path
	i = 0;
	while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

		event.type = i > 1 ?
			bubbleType :
			special.bindType || type;

		// jQuery handler
		// 获取data中的handler句柄
		handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
		if ( handle ) {
			//这里是真正的执行函数,data是jquery生成的event事件对象
			handle.apply( cur, data );
		}

		// Native handler
		handle = ontype && cur[ ontype ];
		if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
			event.preventDefault();
		}
	}
	event.type = type;

	// If nobody prevented the default action, do it now
	if ( !onlyHandlers && !event.isDefaultPrevented() ) {

		if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
			jQuery.acceptData( elem ) ) {

			// Call a native DOM method on the target with the same name name as the event.
			// Don't do default actions on window, that's where global variables be (#6170)
			if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

				// Don't re-trigger an onFOO event when we call its FOO() method
				tmp = elem[ ontype ];

				if ( tmp ) {
					elem[ ontype ] = null;
				}

				// Prevent re-triggering of the same event, since we already bubbled it above
				jQuery.event.triggered = type;
				elem[ type ]();
				jQuery.event.triggered = undefined;

				if ( tmp ) {
					elem[ ontype ] = tmp;
				}
			}
		}
	}

	return event.result;
},
```


## 13.2.7 `$.event.simulate()`

- 调用`$.event.trigger` / `$.event.dispatch`

>源码

``` javascript
simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
```

## 13.2.8 `$.event.remove()`


``` javascript
// Detach an event or set of events from an element
remove: function( elem, types, handler, selector, mappedTypes ) {
	var j, origCount, tmp,
		events, t, handleObj,
		special, handlers, type, namespaces, origType,
		elemData = data_priv.hasData( elem ) && data_priv.get( elem );

	if ( !elemData || !(events = elemData.events) ) {
		return;
	}

	// Once for each type.namespace in types; type may be omitted
	types = ( types || "" ).match( core_rnotwhite ) || [""];
	t = types.length;
	while ( t-- ) {
		tmp = rtypenamespace.exec( types[t] ) || [];
		type = origType = tmp[1];
		namespaces = ( tmp[2] || "" ).split( "." ).sort();

		// Unbind all events (on this namespace, if provided) for the element
		if ( !type ) {
			for ( type in events ) {
				jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
			}
			continue;
		}

		special = jQuery.event.special[ type ] || {};
		type = ( selector ? special.delegateType : special.bindType ) || type;
		handlers = events[ type ] || [];
		tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

		// Remove matching events
		origCount = j = handlers.length;
		while ( j-- ) {
			handleObj = handlers[ j ];

			if ( ( mappedTypes || origType === handleObj.origType ) &&
				( !handler || handler.guid === handleObj.guid ) &&
				( !tmp || tmp.test( handleObj.namespace ) ) &&
				( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
				handlers.splice( j, 1 );

				if ( handleObj.selector ) {
					handlers.delegateCount--;
				}
				if ( special.remove ) {
					special.remove.call( elem, handleObj );
				}
			}
		}

		// Remove generic event handler if we removed something and no more handlers exist
		// (avoids potential for endless recursion during removal of special event handlers)
		if ( origCount && !handlers.length ) {
			if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
				jQuery.removeEvent( elem, type, elemData.handle );
			}
			
			//删除data缓存中的事件
			delete events[ type ];
		}
	}

	// Remove the expando if it's no longer used
	// 如果data中的events为空
	if ( jQuery.isEmptyObject( events ) ) {
		//删除data对应的缓存
		delete elemData.handle;
		data_priv.remove( elem, "events" );
	}
},
```


>内容解析

``` javascript
var $div = $("#div"),
    $div2 = $("#div2");
$div.on('click.aaa',function() {
    alert('div1 click aaa');
})

$div2.on('click.aaa',function() {
    alert('div2 click aaa');
})

$div2.on('mouseenter.aaa',function() {
    alert('div2 mouseenter aaa');
})

$div2.on('click',function() {
    alert('div2 click');
})

// $div2.off('click'); //取消了所有的div2的click事件
$div2.off('.aaa');     //取消了所有div2命名空间为aaa的事件
```
